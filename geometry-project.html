<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>交互式几何结构可视化</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .main-container {
            max-width: 900px;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }
        .info-container {
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .info-container h1 {
            margin-top: 0;
            font-size: 2em;
            color: #1a1a1a;
        }
        .info-container p {
            line-height: 1.6;
            font-size: 1.1em;
        }
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        .controls button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        .controls button.active {
            background-color: #004085;
            font-weight: bold;
        }
        #visualization-container {
            width: 100%;
            height: 500px; /* 定义一个固定高度 */
            background-color: #000;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        /* 加载指示器 */
        #loader {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2em;
        }
    </style>
</head>
<body>

    <div class="main-container">
        <div class="info-container">
            <h1 id="structure-title">交互式几何结构</h1>
            <p id="structure-description">
                欢迎来到交互式几何学习工具。空间并不仅仅是我们所见的虚空，它可以通过添加不同的数学“结构”来获得丰富的特性。请点击下方按钮，探索从“柔软”的拓扑空间到“刚性”的度量空间的不同几何世界。
            </p>
        </div>

        <div class="controls">
            <button id="btn-topology" class="control-btn">拓扑结构</button>
            <button id="btn-affine" class="control-btn">仿射结构</button>
            <button id="btn-differentiable" class="control-btn">可微分结构</button>
            <button id="btn-metric" class="control-btn">度量结构</button>
        </div>

        <div id="visualization-container">
            <div id="loader">加载中...</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.165.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ---- 全局变量 ----
        let scene, camera, renderer, controls;
        let currentObject = null; // 当前场景中的主要对象
        const visContainer = document.getElementById('visualization-container');
        const loader = document.getElementById('loader');

        // ---- 文本内容 ----
        const descriptions = {
            'topology': {
                title: '拓扑结构 (Topology)',
                text: '拓扑只关心物体的连通性和洞的数量，而不在乎形状和大小。一个甜甜圈可以被平滑地捏成一个咖啡杯，因为它们都有一个洞。这个环面正在随机变形，但它始终是一个环面。'
            },
            'affine': {
                title: '仿射结构 (Affine)',
                text: '仿射结构引入了“直线”和“平行”的概念。你可以看到，即使整个空间被剪切变换（一种仿射变换），网格线依然是直的，并且相互平行的线族依然保持平行。'
            },
            'differentiable': {
                title: '可微分结构 (Differentiable)',
                text: '可微分结构让空间变得“光滑”，允许我们进行微积分。在这个光滑的曲面上，每一点都可以找到一个局部近似的平面，即“切平面”。目前功能简化，展示一个光滑流形。'
            },
            'metric': {
                title: '度量结构 (Metric)',
                text: '度量结构最终定义了“距离”和“角度”。在球面上，两点间的最短路径（测地线）是一段大圆弧，而不是直线。这个红色的线展示了球面上的一条测地线。'
            }
        };

        // ---- 初始化场景 ----
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, visContainer.clientWidth / visContainer.clientHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(visContainer.clientWidth, visContainer.clientHeight);
            visContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            animate();
            loader.style.display = 'none';
        }
        
        // ---- 清理场景 ----
        function clearScene() {
            if (currentObject) {
                scene.remove(currentObject);
                currentObject.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
        }

        // ---- 可视化函数 ----
        function showTopology() {
            clearScene();
            const geometry = new THREE.TorusGeometry(2, 0.5, 32, 100);
            const material = new THREE.MeshStandardMaterial({ color: 0x2196f3, wireframe: true });
            const torus = new THREE.Mesh(geometry, material);
            scene.add(torus);
            currentObject = torus;

            // 保存原始顶点位置
            currentObject.userData.originalVertices = Array.from(geometry.attributes.position.array);
            currentObject.userData.time = 0;

            camera.position.set(0, 0, 5);
            controls.update();
        }

        function showAffine() {
            clearScene();
            const grid = new THREE.GridHelper(4, 10, 0x888888, 0x444444);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);
            currentObject = grid;
            
            // 应用一个剪切变换矩阵
            const shearMatrix = new THREE.Matrix4();
            // a, b, c, d
            // x' = x + ky
            // y' = y
            const k = 0.5; // shear factor
            shearMatrix.set(
                1, k, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            );
            currentObject.applyMatrix4(shearMatrix);
            
            camera.position.set(0, 0, 5);
            controls.update();
        }

        function showDifferentiable() {
            clearScene();
            const geometry = new THREE.SphereGeometry(2, 64, 32); // 用球面作为光滑流形的例子
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00ff88, 
                roughness: 0.5, 
                metalness: 0.1 
            });
            const manifold = new THREE.Mesh(geometry, material);
            scene.add(manifold);
            currentObject = manifold;
            camera.position.set(0, 0, 5);
            controls.update();
        }

        function showMetric() {
            clearScene();
            const group = new THREE.Group();
            
            // 球体
            const sphereGeom = new THREE.SphereGeometry(2, 64, 32);
            const sphereMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.2 
            });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            group.add(sphere);

            // 测地线 (大圆弧)
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(2, 0, 0),
                new THREE.Vector3(0, 2, 0).normalize().multiplyScalar(2),
                new THREE.Vector3(-2, 0, 0),
            ]);
            const points = curve.getPoints(50);
            const lineGeom = new THREE.BufferGeometry().setFromPoints(points);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
            const geodesic = new THREE.Line(lineGeom, lineMat);
            group.add(geodesic);
            
            scene.add(group);
            currentObject = group;
            camera.position.set(0, 0, 5);
            controls.update();
        }

        // ---- 动画循环 ----
        function animate() {
            requestAnimationFrame(animate);

            // 特定于拓扑的动画：顶点变形
            if (currentObject && currentObject.userData.originalVertices) {
                currentObject.userData.time += 0.01;
                const time = currentObject.userData.time;
                const positions = currentObject.geometry.attributes.position.array;
                const original = currentObject.userData.originalVertices;

                for (let i = 0; i < positions.length; i += 3) {
                    const x = original[i];
                    const y = original[i+1];
                    const z = original[i+2];
                    positions[i] = x + 0.1 * Math.sin(y * 2 + time);
                    positions[i+1] = y + 0.1 * Math.cos(x * 2 + time);
                }
                currentObject.geometry.attributes.position.needsUpdate = true;
                currentObject.geometry.computeVertexNormals();
            }

            controls.update();
            renderer.render(scene, camera);
        }
        
        // ---- 事件绑定 ----
        function updateDescription(key) {
             document.getElementById('structure-title').innerText = descriptions[key].title;
             document.getElementById('structure-description').innerText = descriptions[key].text;

             document.querySelectorAll('.control-btn').forEach(b => b.classList.remove('active'));
             document.getElementById('btn-' + key).classList.add('active');
        }

        document.getElementById('btn-topology').addEventListener('click', () => {
            showTopology();
            updateDescription('topology');
        });
        document.getElementById('btn-affine').addEventListener('click', () => {
            showAffine();
            updateDescription('affine');
        });
        document.getElementById('btn-differentiable').addEventListener('click', () => {
            showDifferentiable();
            updateDescription('differentiable');
        });
        document.getElementById('btn-metric').addEventListener('click', () => {
            showMetric();
            updateDescription('metric');
        });
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = visContainer.clientWidth / visContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(visContainer.clientWidth, visContainer.clientHeight);
        });

        // ---- 启动 ----
        init();
        // 默认显示第一个
        document.getElementById('btn-topology').click();

    </script>
</body>
</html>